#The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
#1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#Let us list the factors of the first seven triangle numbers:
#1: 1
#3: 1,3
#6: 1,2,3,6
#10: 1,2,5,10
#15: 1,3,5,15
#21: 1,3,7,21
#28: 1,2,4,7,14,28
#We can see that 28 is the first triangle number to have over five divisors.
#What is the value of the first triangle number to have over five hundred divisors?
n = 1

from functools import reduce

def tringl(n):
  return int(n*(n+1)/2)

def divisors(tn):
  return len((reduce(list.__add__, ([i, tn//i] for i in range(1, int(tn**0.5) + 1) if not tn % i))))

def find(n):
 i = 1
 for i in range(1,100000):
  nn = tringl(i)
  f = divisors(nn)
  i += 1
  if f > 500:
   break
 return nn, f

print(find(n))

#Process: So I'm thinking I'm going to loop ns and check number of divisors for each trianglenumber,
#but it's getting messy real fast. Had a code working with the example, but it's no use for bigger numbers(again).

#...Some hours later still having problems writing efficient code. There may be something fundamentally
#inefficient in how I'm thinking of solving this problem.
#Now manually testing different ns for it's divisors, n could be anywhere, and the loop is already slowing down at 10000(2.8 seconds to run!).
#Found this blog https://alexwlchan.net/2019/07/finding-divisors-with-python. Didn't do much with this, but figured it is relevant.

#Finally I found this factors-code using reduce at https://stackoverflow.com/questions/6800193/what-is-the-most-efficient-way-of-finding-all-the-factors-of-a-number-in-python
#Thanks to user "agf", I thought I would get away with another short cut,
#but turns out I still can't figure out how to loop my way ahead with this.

#Even more hours later, mindlessly fidgeting this code- I suddenly got some output-
#and shockingly got the right answer... finished in 4.373 seconds that is.
#Before putting the code in functions, it was badly nested with variables trying to define eachother.
#First time getting some function action without using a template. Not sure if I needed three separate functions, don't care.
#Forgot how to do the basic n+=1 looping, so the solution was setting a random big number for range in find().
#No spesific takeaways from this, just that function calls can manage what a nesty mess can't.
